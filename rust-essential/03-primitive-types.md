# 基础数据类型

Rust和其他编程语言一样，包含多种常用的基础数据类型，接下来我们就要逐一的介绍这些基础数据类型，但在介绍之前，我们首先来说明一下，在Rust中如何声明变量。

## 变量声明

在Rust中通过`let`关键字，来声明一个变量。而且在声明变量时，不需要显式的给出变量类型，Rust编译器会自动进行类型推断，例如在下面的代码中，我们就声明了一个名为`x`的整型变量：

```rust
let x = 1;
```

当然，你也可以把声明和赋值分开，Rust会以你第一次赋值时值的类型作为变量的类型，一下的Rust代码和上面的完全等价：

```rust
let x;
x = 1;
```

如果我们使用那些未经赋值的变量，Rust编译器在编译过程就会直接报错。

现在我们已经知道如何在Rust中定义变量了，接下来我们开始介绍Rust中的基础数据类型。Rust给我们提供了多种基础数据类型，除了整型，还有浮点数，布尔值，字符等等。

## 整型

在Rust中，我们可以如下定义整型变量，这里使用了Rust提供的自动类型推断（默认为`i32`）：

```rust
let x = 1;
```

此外，我们也可以明确的告诉Rust编译器变量的类型，例如我们可以明确的定义一个32位的整型变量：

```rust
let x: i32 = 1;
```

除了32位整型，Rust中还可以定义如下的整型变量

|标注|类型|范围|
|-|-|-|
|i8|8位有符号整型|[-128, 127]|
|i16|16位有符号整型|[-32768, 32767]|
|i32|32位有符号整型|[-32768, 32767]|
|i64|64位有符合整型|[-9223372036854775808, 9223372036854775807]|
|isize|系统有符号整型，（在32位系统为i32，64位系统则是i64）||
|u8|8位无符合整型（主要用于表示一个byte的数据）|[0, 255]|
|u16|16位无符号整型|[0, 65535]|
|u32|32位无符号整型|[0, 4294967295]|
|u64|64位无符号整型|[0, 18446744073709551615]|
|usize|系统无符号整型，（在32位系统为u32，64位系统则是u64，主要用于数组下标）||

## 浮点数

在Rust中可以定义`f32`和`f64`两种浮点数类型，对应与C/C++中的`float`和`double`，以下是通过类型推断定义了一个浮点数变量`x`（默认为`f64`），以及通过明确标注的方式，定义了一个64位浮点数变量`y`：

```rust
let x = 1.1;
let y: f64 = 1.11;
```

|标注|类型|范围|
|-|-|-|
|f32|单精度浮点数|[-3.40282347e+38f32, 3.40282347e+38f32]|
|f64|双精度浮点数|[-1.7976931348623157e+308f64, 1.7976931348623157e+308f64]|

在声明浮点数时，可以使用科学计数法：

```rust
let x = 4e6; // >> 4000000.0
let y = 4.555e2 // >> 455.5
```

同时，可以声明一个"not-a-number"的浮点数：

```rust
let x:f32 = std::f32::NAN;
let x:f64 = std::f64::NAN;
```

### 【补充】Rust数字类型

整型和浮点数都是Rust中的数字类型，Rust中的数字类型都是基于固定宽度的，任何越界的操作在编译时都会报错：

```rust
let x = std::i32::MAX;
let y = x + 1;
// >> panicked at 'attempt to add with overflow'
```

除了通过类型标注，Rust还可以通过后缀的方式指定数字类型：

```rust
// 定义32位整型
let x = 34i32;
// 定义64为浮点数
let y = 1.03f64;
```

另外你也可以通过2进制，8进制，16进制的方式输入数字：

```rust
// 2进制，0b前缀
let x = 0b0010; // >> 2
// 8进制，0o前缀
let y = 0o713; // >> 459
// 16进制，0x前缀，也可以同时加上类型后缀
let z = 0xff0000u32;
```

同时为了可读性，Rust中的数字，可以通过加入_来分隔不同的部分：

```rust
let x = 130_000_000; // >> 130000000
let y = 0b1001_0110; // >> 0b10010110
let z = 32_u8;
```

在某些情况下，你可能希望通过ascii字符的形式来输入数字，就像C/C++中那样，Rust也提供了这样的方式：

```rust
let x = b'X'; // >> 88
// 部分字符需要转义
let a = b'\'';
let b = b'\\';
let c = b'\n';
let d = b'\r';
let e = b'\t';
// 也可以使用16进制
let k = b'\x1b'; // >> 27, ascii escape
```

Rust并不会对你的数字类型进行隐式转换，相反，Rust需要你通过明确的语法来转换不同的数字类型：

```rust
let x:i32 = 1;
// 通过as关键字，可以对数字类型进行转换
let y:f64 = x as f64;
```

## 布尔值

在Rust中可以定义布尔值`true`和`false`：

```rust
let x = true;
let y: bool = false;
```

通过`as`关键字，Rust可以把布尔值转换成整型：

```rust
let x = true;
let y = x as i32;
let z = x as u32;
```

然而反过来是不行的，而且Rust中所有需要使用布尔值的地方（条件判断）都必须是布尔值，而不像其他语音那样，可以通过把数字，字符其他类隐式转换成布尔值。因此如下代码在Rust是直接编译不通过：

```rust
let x = 2;
if x {
    // do something
}
// >> expected bool, found integral variable
```

## 字符型

在Rust中的字符类型和C/C++中的字符类型不太一样，Rust中的字符对应的是unicode编码的单个字符（32位），而C/C++中的字符，实际是一个8位无符号整型，因此Rust中的字符即可以放入英文字母，也可以放入中文，印度文甚至emoji表情。注意字符型数据是以单引号包裹：

```rust
let x = 'a';
let y = '中';
let z: char = '😁';
// 需要转义的字符
let a = '\'';
let b = '\\';
let c = '\n';
let d = '\r';
let e = '\t';
// 通过16进制表示的字符
// 如果该字符是ascii字符，可以通过\xHH的方式表示
let f = '\x1b';
// 而对于所有的unicode字符，都可以通过\u{HHHHHH}的方式表示
let i = '\u{ca0}';
```

通过`as`关键字，Rust可以把字符型转换成整型：

```rust
let x = '中';
let y = x as i32; // >> 20013
let z = x as u8; // >> 45，对与高位，Rust会截断
```

但相反，Rust只能使用`as`关键字把`u8`类型的数字转换成字符型，这是由于在Rust底层对`as`的操作实际是简单改变类型标记，而不会对数据本身进行任何校验，而unicode编码本身，并没有覆盖除了`u8`（ascii字符）以外的其他数字范围，所以Rust拒绝了这样的“不安全”的转换，因此如下代码，在编译过程中就会报错：

```rust
let x: i32 = 27;
let y = x as char;
// >> only `u8` can be cast as `char`, not `i32`
```

## 字符串

在Rust中除了可以定义字符型以外，我们还可以直接定义字符串。和字符型变量不一样，Rust中字符串实际对应的是utf-8编码的字符串序列，而不是字符数组。注意字符串数据是以双引号包裹：

```rust
let x = "abc";
let y: &str = "程序猿";
```

可能有些同学已经注意到，上面的代码中，字符串的类型标注是`&str`，熟悉C/C++的同学应该猜到这是一个指针，或者准确来说是一个胖指针，包含一个字符串起始地址和一个字符串长度。那为什么在Rust中定义字符串不直接使用`str`，而是使用了`&str`呢？其实这是由于Rust本身是一门类型安全的语言，在Rust中不允许任何越界操作。为了实现这样的目的，Rust在编译过程必须知道每一个变量的字长。而不同于字符型变量是32位定长数据，字符串变量所保存的utf-8编码数据实际在编译过程中Rust编译器无法计算出其长度，因此Rust的做法，是把字符串字面量数据保存在程序二进制文件中，在程序启动时载入内存，然后通过指针的方式引用该数据，而指针实际是一个`usize`的定长数据，因此Rust就可以编译通过。

Rust中的字符串，可以保存多行文本，如下面这一段代码中，我们声明了一个字符串`x`，在`x`中的换行符被保留了下来，当然，除此以外，第二行文本前面的那些空格也被保存下来了：

```rust
let x = "abc
    bbc";
```

有些时候，我们只是想使得代码的排版好看一些而对文本进行换行而并不希望在文本中插入换行符，这时候，我们可以在行末加上一个反斜杠，这时候，不但换行符没有保留，连第二行文本前面的那些空格也没有保留：

```rust
let x = "abc\
    bbc;
```

此外，有一些特殊的情况下，例如我们要编写正则表达式，或者windows下的文件路径时，我们可能会在字符串中插入很多需要转义的字符，这时候代码的可读性就有可能变差，为了解决这样的问题，Rust引入了raw字符串（可能是从Python中学来的），通过在字符串开头加入字母`r`，其后的字符串都不需要加入转义字符：

```rust
let x = r"^\d{4}-\d{2}-\d{2}$";
```

但如果你的raw字符串中，需要包含双引号，例如像一些html字符串，该怎么办呢？这时我们可以在字母`r`之后跟上若干个`#`，而在字符串结束的地方，相对应的加上相同数量的`#`，这样raw字符串中的双引号也能正确的识别出来：

```rust
let x = r###"
    <p id="text">这是一段html</p>
"###;
```

## 元组

元组对于接触过Python的同学应该都不会陌生。元组是一种，可以方便的，把固定数量的不同类型数据临时组合在一起的，一种数据类型，通常用于函数需要返回多个值的情况：

```rust
// x的类型为(i32, f64, &str)
let x = (1, 1.1, "rust");
```

在Rust中，通过把多个逗号分割的变量放置在括号中形成一个元组，通过下标访问其中的项，但下标只能为常量，其实这也不难理解。由于Rust是类型安全的，需要在编译时知道每一个变量的字长，如果利用变量作为下标访问元组，Rust编译器在编译时就无法知道具体访问的项，也就无法推算出字长。除了可以通过下标访问元组中的项，Rust也支持类似JS中的析构语法：

```rust
let x = (1, 1.1, "rust");
let a = x.0;
let b = x.1;
let c = x.2;

// 使用变量下标访问元组，在编译时报错
let d = x.i;
// >> no field `i` on type `({integer}, {integer})`

// 析构语法
let (d, e, f) = x;
// 等价于
// let d = x.0;
// let e = x.1;
// let f = x.2;
```

## 数组

Rust中也支持定义数组，通过把多个逗号分割的变量放置在方括号中形成一个数组。

```rust
// x的类型为[i32; 3]
let x = [1, 2, 3];
```

和元组一样，数组中只能包含固定个数的数据，可以通过下标访问数组中的项。但和元组不同，元组中可以放入不同类型的数据，而数组中的数据则要求是相同类型的，这也间接导致了数组和元组的另一个同，即数组的下标可以以变量的形式出现（在这种情况下，Rust编译器仍能推断出变量的字长）：

```rust
let x = [1, 2, 3];
let a = x[0];
// 以变量i作为下标
let i = 1;
let b = x[i];
let c = x[i + 1];
```

## 切片

说到数组，我们就不能不提Rust中提供的另一种基础数据类型：切片。切片实际上也是一个胖指针，包含一个起始地址（指向栈或者堆均可）加上一段长度，用以标记某个数组中的一部分（例如数组中的一部分）：

```rust
let x = [1, 2, 3];
// y是x的一个切片，类型为&[i32]
let y = &x[0..2];
```

切片有则和数组几乎一致的行为，我们可以通过下标访问切片上的项，也可以在切片上调用那些本应作用在数组的方法，或者更确切地说，在Rust中这些“操作数组”的方法实际上是定义在切片上的，只是Rust编译器在编译的过程中，如果发现我们在数组中调用这些方法，Rust会自动的把这个数组转化成对应的切片，并继续在切片上调用这些方法：

```rust
let x = [1, 2, 3];
// 实际上Rust在编译时，会把x转化成&x，即x的切片
let xlen = x.len();

let y = &x[..];
let ylen = y.len();

// 数组排序
y.sort();
// 位置调换
y.swap(0, 1);
```

其实如果有细心的同学，应该也会猜到，Rust中的字符串`&str`实际上也是一个切片（保存则某个字符串起始指针，以及字符串的长度，可以理解成一个类型为`&[u8]`切片），但是为了保护字符串中的utf-8编码安全，Rust对`&str`的下标访问做了限制，避免了从字符串中某个多位编码的字符中间切开。

```rust
let x = "中国";
// 以下情况均会报错

// 编译时错误
let y = x[0];
// the trait bound `str: std::ops::Index<{integer}>` is not satisfied

// 运行时错误
let y = &x[1..];
// panicked at 'byte index 1 is not a char boundary; it is inside '中' (bytes 0..3) of `中国`
```